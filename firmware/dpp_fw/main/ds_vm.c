#include <stdio.h>    /* printf */
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

#include "rotary_encoder.h"
#include "input_task.h"
#include "sd_task.h"
#include "ui_task.h"
#include "neopixel_task.h"
#include "shared.h"
#include "profiles.h"
#include "ssd1306.h"
#include "keypress_task.h"
#include "keyboard.h"
#include "ds_vm.h"
#include "input_task.h"
#include "dsb_cache.h"
#include "shared.h"
#include "hid_task.h"

#include <setjmp.h>

uint8_t str_print_format;
uint8_t str_print_padding;
uint8_t bin_buf[BIN_BUF_SIZE] __attribute__((aligned(4)));
uint32_t defaultdelay;
uint32_t defaultchardelay;
uint32_t charjitter;
uint32_t rand_min, rand_max;
uint32_t loop_size;
uint8_t epilogue_actions;
uint8_t allow_abort;
uint8_t kb_led_status;
uint8_t disable_autorepeat;
uint32_t pgv_buf[PGV_COUNT];
static jmp_buf jmpbuf;
uint8_t current_key_id = 127;
uint8_t unsigned_math;

// ---------------------------


    /*
    AUTO GENERATED BY 
    print_C_opcode_len_lookup()
    print_C_opcode_def()
    IN dsvm_common.py
    */
    
#define OP_LEN_LOOKUP_SIZE 100
uint8_t opcode_len_lookup[OP_LEN_LOOKUP_SIZE] = {
1, // [0] NOP
3, // [1] PUSHC16
3, // [2] PUSHI
3, // [3] PUSHR
3, // [4] POPI
3, // [5] POPR
3, // [6] BRZ
3, // [7] JMP
3, // [8] ALLOC
3, // [9] CALL
3, // [10] RET
1, // [11] HALT
255, // [12]
255, // [13]
255, // [14]
255, // [15]
255, // [16]
255, // [17]
255, // [18]
255, // [19]
255, // [20]
255, // [21]
255, // [22]
255, // [23]
255, // [24]
255, // [25]
255, // [26]
255, // [27]
255, // [28]
255, // [29]
255, // [30]
255, // [31]
1, // [32] EQ
1, // [33] NOTEQ
1, // [34] LT
1, // [35] LTE
1, // [36] GT
1, // [37] GTE
1, // [38] ADD
1, // [39] SUB
1, // [40] MULT
1, // [41] DIV
1, // [42] MOD
1, // [43] POW
1, // [44] LSHIFT
1, // [45] RSHIFT
1, // [46] BITOR
1, // [47] BITXOR
1, // [48] BITAND
1, // [49] LOGIAND
1, // [50] LOGIOR
255, // [51]
255, // [52]
255, // [53]
255, // [54]
1, // [55] BITINV
1, // [56] LOGINOT
1, // [57] USUB
255, // [58]
255, // [59]
255, // [60]
255, // [61]
255, // [62]
255, // [63]
1, // [64] DELAY
1, // [65] KDOWN
1, // [66] KUP
1, // [67] MSCL
1, // [68] MMOV
1, // [69] SWCF
1, // [70] SWCC
1, // [71] SWCR
1, // [72] STR
1, // [73] STRLN
1, // [74] OLED_CUSR
1, // [75] OLED_PRNT
1, // [76] OLED_UPDE
1, // [77] OLED_CLR
1, // [78] OLED_REST
1, // [79] OLED_LINE
1, // [80] OLED_RECT
1, // [81] OLED_CIRC
1, // [82] BCLR
1, // [83] SKIPP
1, // [84] GOTOP
1, // [85] SLEEP
255, // [86]
255, // [87]
255, // [88]
255, // [89]
255, // [90]
255, // [91]
255, // [92]
255, // [93]
255, // [94]
255, // [95]
255, // [96]
255, // [97]
255, // [98]
255, // [99]
};

#define OP_NOP 0
#define OP_PUSHC16 1
#define OP_PUSHI 2
#define OP_PUSHR 3
#define OP_POPI 4
#define OP_POPR 5
#define OP_BRZ 6
#define OP_JMP 7
#define OP_ALLOC 8
#define OP_CALL 9
#define OP_RET 10
#define OP_HALT 11
#define OP_EQ 32
#define OP_NOTEQ 33
#define OP_LT 34
#define OP_LTE 35
#define OP_GT 36
#define OP_GTE 37
#define OP_ADD 38
#define OP_SUB 39
#define OP_MULT 40
#define OP_DIV 41
#define OP_MOD 42
#define OP_POW 43
#define OP_LSHIFT 44
#define OP_RSHIFT 45
#define OP_BITOR 46
#define OP_BITXOR 47
#define OP_BITAND 48
#define OP_LOGIAND 49
#define OP_LOGIOR 50
#define OP_BITINV 55
#define OP_LOGINOT 56
#define OP_USUB 57
#define OP_DELAY 64
#define OP_KDOWN 65
#define OP_KUP 66
#define OP_MSCL 67
#define OP_MMOV 68
#define OP_SWCF 69
#define OP_SWCC 70
#define OP_SWCR 71
#define OP_STR 72
#define OP_STRLN 73
#define OP_OLED_CUSR 74
#define OP_OLED_PRNT 75
#define OP_OLED_UPDE 76
#define OP_OLED_CLR 77
#define OP_OLED_REST 78
#define OP_OLED_LINE 79
#define OP_OLED_RECT 80
#define OP_OLED_CIRC 81
#define OP_BCLR 82
#define OP_SKIPP 83
#define OP_GOTOP 84
#define OP_SLEEP 85
#define OP_VMVER 255

// ---------------------------

my_stack data_stack;

// vm_stack_base: The virtual address where stack starts (e.g., 0xF7FF)
void stack_init(my_stack* ms, uint8_t* ram_base, uint16_t vm_stack_base, uint16_t size_bytes)
{
    // 1. Store the host memory base
    ms->ram_base = ram_base;

    // 2. Align the virtual base address (rounding down to nearest 4-byte boundary)
    //    If vm_stack_base is 0xF7FF, this becomes 0xF7FC
    uint16_t aligned_base = vm_stack_base & ~0x03;

    // 3. Set bounds
    ms->upper_bound = aligned_base; 
    ms->lower_bound = aligned_base - size_bytes;

    // 4. Initialize registers
    //    Matches your original logic: SP points to the current empty slot.
    //    We start "one slot down" so the first write occupies the top-most aligned bytes.
    ms->sp = ms->upper_bound - sizeof(uint32_t); 
    ms->fp = ms->upper_bound;

    // 5. Clear memory (Translation: Host Addr = ram_base + virtual_offset)
    memset(ms->ram_base + ms->lower_bound, 0, size_bytes);
}

void stack_push(my_stack* ms, uint32_t in_value)
{
  if (ms->sp < ms->lower_bound) 
    longjmp(jmpbuf, EXE_STACK_OVERFLOW);
  uint8_t* host_addr = ms->ram_base + ms->sp;
  memcpy(host_addr, &in_value, sizeof(uint32_t));
  ms->sp -= sizeof(uint32_t);
}

void stack_pop(my_stack* ms, uint32_t *out_value)
{
  uint16_t next_sp = ms->sp + sizeof(uint32_t);
  if (next_sp >= ms->upper_bound)
    longjmp(jmpbuf, EXE_STACK_UNDERFLOW);
  ms->sp = next_sp;
  uint8_t* host_addr = ms->ram_base + ms->sp;
  if(out_value != NULL)
    memcpy(out_value, host_addr, sizeof(uint32_t));
}

uint8_t read_byte(uint16_t addr)
{
  return bin_buf[addr];
}

void stack_write_fp_rel(my_stack* ms, int16_t offset, uint32_t value)
{
  if (offset & 0x03)
    longjmp(jmpbuf, EXE_UNALIGNED_ACCESS);
  uint16_t target_addr = ms->fp + offset;
  if (target_addr < ms->lower_bound || target_addr > (ms->upper_bound - sizeof(uint32_t)))
    longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
  uint8_t* host_addr = ms->ram_base + target_addr;
  memcpy(host_addr, &value, sizeof(uint32_t));
}

void stack_read_fp_rel(my_stack* ms, int16_t offset, uint32_t* value)
{
  if (offset & 0x03)
    longjmp(jmpbuf, EXE_UNALIGNED_ACCESS);

  uint16_t target_addr = ms->fp + offset;
  if (target_addr < ms->lower_bound || target_addr > (ms->upper_bound - sizeof(uint32_t)))
    longjmp(jmpbuf, EXE_ILLEGAL_ADDR);

  uint8_t* host_addr = ms->ram_base + target_addr;
  memcpy(value, host_addr, sizeof(uint32_t));
}

void stack_print(my_stack* ms, char* comment)
{
  if(PRINT_DEBUG == 0)
    return;
  printf("\n=== STACK STATE: %s ===\n", comment);
  printf("------------------------\n");

  // 1. Start iteration directly at SP (The Free Slot)
  //    We loop from SP (Low Address) up to Upper Bound (High Address)
  uint16_t current_v_addr = ms->sp;

  // 2. Iterate
  while (current_v_addr <= ms->upper_bound)
  {
    // Translate Virtual Addr -> Host Addr
    uint8_t* host_addr = ms->ram_base + current_v_addr;
    
    // Read value safely (Note: For the free slot, this is technically garbage/uninitialized data)
    uint32_t val;
    memcpy(&val, host_addr, sizeof(uint32_t));

    // Print Line: [Addr]  HexValue
    printf(" [0x%04X]  0x%08X  ", current_v_addr, (unsigned int)val);

    // 3. Special handling for the SP (Free Slot) vs Data Slots
    if (current_v_addr == ms->sp) 
    {
      // This is the empty slot waiting for the next push
      printf("<----------------------- SP");
    }
    else 
    {
      // This is actual data
      printf("(%10d)", (int)val);
      // Mark the actual Top of Stack data (the item most recently pushed)
      if (current_v_addr == ms->sp + sizeof(uint32_t))
        printf("  [TOS]");
    }

    // Add visual markers for Frame Pointer
    if (current_v_addr == ms->fp)
      printf(" <--- FP");
    // Mark the Stack Bottom (First item pushed)
    if (current_v_addr == ms->upper_bound)
      printf("  [BOTTOM]");
    printf("\n");
    // Move to the next item (higher address)
    current_v_addr += sizeof(uint32_t);
  }
  printf("========================\n\n");
}

uint32_t binop_equal(uint32_t a, uint32_t b) {return a == b;}
uint32_t binop_not_equal(uint32_t a, uint32_t b) {return a != b;}
uint32_t binop_lower(uint32_t a, uint32_t b)
{
  if(unsigned_math)
    return a < b;
  return (int32_t)a < (int32_t)b;
}
uint32_t binop_lower_eq(uint32_t a, uint32_t b)
{
  if(unsigned_math)
    return a <= b;
  return (int32_t)a <= (int32_t)b;
}
uint32_t binop_greater(uint32_t a, uint32_t b)
{
  if(unsigned_math)
    return a > b;
  return (int32_t)a > (int32_t)b;
}
uint32_t binop_greater_eq(uint32_t a, uint32_t b)
{
  if(unsigned_math)
    return a >= b;
  return (int32_t)a >= (int32_t)b;
}
uint32_t binop_add(uint32_t a, uint32_t b) {return a + b;}
uint32_t binop_sub(uint32_t a, uint32_t b) {return a - b;}
uint32_t binop_mul(uint32_t a, uint32_t b) {return a * b;}
uint32_t binop_mod(uint32_t a, uint32_t b)
{
  if(b == 0)
    longjmp(jmpbuf, EXE_DIVISION_BY_ZERO);
  if(unsigned_math)
    return a % b;
  return (int32_t)a % (int32_t)b;
}
uint32_t binop_lshift(uint32_t a, uint32_t b) {return a << b;}
uint32_t binop_rshift(uint32_t a, uint32_t b)
{
  if(unsigned_math)
    return a >> b;
  return (int32_t)((int32_t)a >> (int32_t)b);
}
uint32_t binop_bitwise_or(uint32_t a, uint32_t b) {return a | b;}
uint32_t binop_bitwise_xor(uint32_t a, uint32_t b) {return a ^ b;}
uint32_t binop_bitwise_and(uint32_t a, uint32_t b) {return a & b;}
uint32_t binop_logical_and(uint32_t a, uint32_t b) {return a && b;}
uint32_t binop_logical_or(uint32_t a, uint32_t b) {return a || b;}
uint32_t binop_divide(uint32_t a, uint32_t b)
{
  if(b == 0)
    longjmp(jmpbuf, EXE_DIVISION_BY_ZERO);
  if(unsigned_math)
    return a / b;
  return (int32_t)a / (int32_t)b; 
}
uint32_t binop_power(uint32_t x, uint32_t exponent)
{
  if (unsigned_math == 0 && ((int32_t)exponent < 0))
    return 0;
  uint32_t result = 1;
  for (size_t i = 0; i < exponent; ++i)
    result *= x;
  return result;
}

uint32_t unaop_bit_inv(uint32_t value) {return ~value;}
uint32_t unaop_logical_not(uint32_t value) {return !value;}
uint32_t unaop_usub(uint32_t value) {return value * -1;}

void binop(FUNC_PTR_BINOP bin_func)
{
  uint32_t rhs, lhs;
  stack_pop(&data_stack, &rhs);
  stack_pop(&data_stack, &lhs);
  stack_push(&data_stack, bin_func(lhs, rhs));
  stack_print(&data_stack, "AFTER BINOP");
}

void unaryop(FUNC_PTR_UNARY una_func)
{
  uint32_t value;
  stack_pop(&data_stack, &value);
  stack_push(&data_stack, una_func(value));
  stack_print(&data_stack, "AFTER UNAOP");
}

uint16_t make_uint16(uint8_t b0, uint8_t b1)
{
  return b0 | (b1 << 8);
}

uint8_t get_gv_index(uint16_t addr)
{
  uint8_t gv_index = (addr - PGV_START_ADDRESS) / PGV_BYTE_WIDTH;
  if(gv_index >= PGV_COUNT)
    longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
  return gv_index;
}

uint8_t is_pgv(uint16_t addr)
{
  return addr >= PGV_START_ADDRESS && addr <= PGV_END_ADDRESS_INCLUSIVE;
}

uint32_t make_uint32(const uint8_t* base_addr)
{
  uint32_t result;
  memcpy(&result, base_addr, sizeof(result)); 
  return result;
}

void write_uint32_as_4B(uint8_t* bbuf, uint32_t value)
{
  memcpy(bbuf, &value, sizeof(uint32_t));
}

uint32_t memread_u32(uint16_t addr)
{
  if (addr <= USER_VAR_END_ADDRESS_INCLUSIVE)
    return make_uint32(&bin_buf[addr]);
  if (is_pgv(addr))
    return pgv_buf[get_gv_index(addr)];
  if (addr == _DEFAULTDELAY)
	  return defaultdelay;
  if (addr == _DEFAULTCHARDELAY)
    return defaultchardelay;
  if (addr == _CHARJITTER)
    return charjitter;
  if (addr == _RANDOM_MIN)
    return rand_min;
  if (addr == _RANDOM_MAX)
    return rand_max;
  if (addr == _RANDOM_INT)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _TIME_MS)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _READKEY)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _LOOP_SIZE)
    return loop_size;
  if (addr == _KEYPRESS_COUNT)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _EPILOGUE_ACTIONS)
    return epilogue_actions;
  if (addr == _TIME_S)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _ALLOW_ABORT)
    return allow_abort;
  if (addr == _BLOCKING_READKEY)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _IS_NUMLOCK_ON)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _IS_CAPSLOCK_ON)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _IS_SCROLLLOCK_ON)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _DONT_REPEAT)
    return disable_autorepeat;
  if (addr == _THIS_KEYID)
    return current_key_id;
  if (addr == _DP_MODEL)
    return 2;
  if (addr == _RTC_IS_VALID)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _RTC_UTC_OFFSET)
    return utc_offset_minutes;
  if (addr == _RTC_YEAR)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _RTC_MONTH)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _RTC_DAY)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _RTC_HOUR)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _RTC_MINUTE)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _RTC_SECOND)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _RTC_WDAY)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _RTC_YDAY)
    return DUMMY_DATA_REPLACE_ME;
  if (addr == _STR_PRINT_FORMAT)
    return str_print_format;
  if (addr == _STR_PRINT_PADDING)
    return str_print_padding;
  if (addr == _UNUSED)
    return 0;
  if (addr == _UNSIGNED_MATH)
    return unsigned_math;
  if (addr == _SW_BITFIELD)
    return DUMMY_DATA_REPLACE_ME;
  longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
}

void memwrite_u32(uint16_t addr, uint32_t value)
{
  if (addr <= USER_VAR_END_ADDRESS_INCLUSIVE)
    write_uint32_as_4B(&bin_buf[addr], value);
  else if (is_pgv(addr))
  {
    pgv_buf[get_gv_index(addr)] = value;
    DS_SET_BITS(epilogue_actions, EPI_SAVE_PGV);
  }
  else if (addr == _DEFAULTDELAY)
	  defaultdelay = value;
  else if (addr == _DEFAULTCHARDELAY)
    defaultchardelay = value;
  else if (addr == _CHARJITTER)
    charjitter = value;
  else if (addr == _RANDOM_MIN)
    rand_min = value;
  else if (addr == _RANDOM_MAX)
    rand_max = value;
  else if (addr == _KEYPRESS_COUNT)
    (void)DUMMY_DATA_REPLACE_ME;
  else if (addr == _EPILOGUE_ACTIONS)
    epilogue_actions = value;
  else if (addr == _ALLOW_ABORT)
    allow_abort = value;
  else if (addr == _DONT_REPEAT)
    disable_autorepeat = value;
  else if (addr == _RTC_UTC_OFFSET)
    utc_offset_minutes = value;
  else if (addr == _STR_PRINT_FORMAT)
    str_print_format = value;
  else if (addr == _STR_PRINT_PADDING)
    str_print_padding = value;
  else if (addr == _UNSIGNED_MATH)
    unsigned_math = value;
}

uint8_t load_dsb(char* dsb_path, uint32_t* dsb_size)
{
  FILE *dsb_file = fopen(dsb_path, "rb");
  if(dsb_file == NULL)
    return EXE_DSB_FOPEN_FAIL;
  memset(bin_buf, 0, BIN_BUF_SIZE);
  *dsb_size = fread(bin_buf, 1, BIN_BUF_SIZE, dsb_file);
  fclose(dsb_file);
  if(*dsb_size == 0)
    return EXE_DSB_FREAD_ERROR;
  if(*dsb_size >= MAX_BIN_SIZE)
    return EXE_DSB_FILE_TOO_LARGE;
  if(bin_buf[0] != OP_VMVER)
    return EXE_DSB_INCOMPATIBLE_VERSION;
  if(bin_buf[1] != dsvm_version)
    return EXE_DSB_INCOMPATIBLE_VERSION;
  return EXE_OK;
}

uint8_t str_is_integer(const char *str, long *out_value)
{
  char *endptr;
  long val = strtol(str, &endptr, 0);
  if (str == endptr)
    return 0;
  if (*endptr != '\0')
    return 0;
  if (out_value)
    *out_value = val;    
  return 1;
}

uint8_t inst_size_lookup(uint8_t opcode)
{
  if(opcode == OP_VMVER)
    return 3;
  if(opcode >= OP_LEN_LOOKUP_SIZE || opcode_len_lookup[opcode] > MAX_INSTRUCTION_LEN)
    longjmp(jmpbuf, EXE_ILLEGAL_INSTRUCTION);
  return opcode_len_lookup[opcode];
}

void my_snprintf_int_only(char* buf, uint8_t buf_size,
                         uint32_t value,
                         uint8_t print_format,
                         uint8_t precision)
{
  if (buf == NULL || buf_size <= 2)
    return;

  memset(buf, 0, buf_size);

  if (precision == 0 && value == 0)
  {
    buf[0] = '0';
    return;
  }

  if(precision > 8)
    precision = 8;

  switch (print_format)
  {
    case STR_PRINT_FORMAT_DEC_UNSIGNED:
      snprintf(buf, buf_size, "%.*u", (int)precision, (unsigned int)value);
      break;

    case STR_PRINT_FORMAT_DEC_SIGNED:
      snprintf(buf, buf_size, "%.*d", (int)precision, (int)value);
      break;

    case STR_PRINT_FORMAT_HEX_LOWER_CASE:
      snprintf(buf, buf_size, "%.*x", (int)precision, (unsigned int)value);
      break;

    case STR_PRINT_FORMAT_HEX_UPPER_CASE:
      snprintf(buf, buf_size, "%.*X", (int)precision, (unsigned int)value);
      break;
  }
  buf[buf_size - 1] = '\0';
}

#define STR_BUF_SIZE 32
char make_str_buf[STR_BUF_SIZE];
#define READ_BUF_SIZE (256 * 5)
char read_buffer[READ_BUF_SIZE];

char* make_str(uint16_t str_start_addr)
{
  uint16_t curr_addr = str_start_addr;
  uint8_t this_char, lsb, msb;
  memset(read_buffer, 0, READ_BUF_SIZE);
  while(1)
  {
    this_char = read_byte(curr_addr);
    if(this_char == 0)
      break;

    if(this_char == MAKESTR_VAR_BOUNDARY_IMM)
    {
      curr_addr++;
      lsb = read_byte(curr_addr);
      curr_addr++;
      msb = read_byte(curr_addr);
      curr_addr++;
      curr_addr++;
      uint16_t var_addr = make_uint16(lsb, msb);
      uint32_t var_value = memread_u32(var_addr);
      memset(make_str_buf, 0, STR_BUF_SIZE);
      my_snprintf_int_only(make_str_buf, STR_BUF_SIZE, var_value, str_print_format, str_print_padding);
      strcat(read_buffer, make_str_buf);
      continue;
    }
    if(this_char == MAKESTR_VAR_BOUNDARY_REL)
    {
      curr_addr++;
      lsb = read_byte(curr_addr);
      curr_addr++;
      msb = read_byte(curr_addr);
      curr_addr++;
      curr_addr++;
      int16_t fp_offset = (int16_t)make_uint16(lsb, msb);
      uint32_t var_value;
      stack_read_fp_rel(&data_stack, fp_offset, &var_value);
      memset(make_str_buf, 0, STR_BUF_SIZE);
      my_snprintf_int_only(make_str_buf, STR_BUF_SIZE, var_value, str_print_format, str_print_padding);
      strcat(read_buffer, make_str_buf);
      continue;
    }
    memset(make_str_buf, 0, STR_BUF_SIZE);
    sprintf(make_str_buf, "%c", this_char);
    strcat(read_buffer, make_str_buf);
    curr_addr++;
  }
  return read_buffer;
}

void execute_instruction(uint16_t curr_pc, exe_context* exe)
{
  uint8_t opcode = read_byte(curr_pc);
  uint8_t instruction_size_bytes = inst_size_lookup(opcode);
  uint16_t payload = 0;
  exe->next_pc += instruction_size_bytes;
  
  if(instruction_size_bytes == 3)
    payload = make_uint16(read_byte(curr_pc+1), read_byte(curr_pc+2));
  
  if(PRINT_DEBUG)
  {
    printf("\n--------------------\n");
    printf("PC: %04d    Opcode: %02d    Payload: %04x", curr_pc, opcode, payload);
    printf("\n");
  }

  if(opcode == OP_NOP || opcode == OP_VMVER)
  {
    return;
  }
  else if(opcode == OP_PUSHC16)
  {
    stack_push(&data_stack, payload);
    stack_print(&data_stack, "AFTER PUSHC16");
  }
  else if(opcode == OP_PUSHI)
  {
    stack_push(&data_stack, memread_u32(payload));
    stack_print(&data_stack, "AFTER PUSHI");
  }
  else if(opcode == OP_PUSHR)
  {
    uint32_t this_value;
    stack_read_fp_rel(&data_stack, (int16_t)payload, &this_value);
    stack_push(&data_stack, this_value);
    stack_print(&data_stack, "AFTER PUSHR");
  }
  else if(opcode == OP_POPI)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    memwrite_u32(payload, this_value);
    stack_print(&data_stack, "AFTER POPI");
  }
  else if(opcode == OP_POPR)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    stack_write_fp_rel(&data_stack, (int16_t)payload, this_value);
    stack_print(&data_stack, "AFTER POPR");
  }
  else if(opcode == OP_BRZ)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    if(this_value == 0)
      exe->next_pc = payload;
  }
  else if(opcode == OP_JMP)
  {
    exe->next_pc = payload;
  }
  else if(opcode == OP_ALLOC)
  {
    for (size_t i = 0; i < payload; i++)
      stack_push(&data_stack, 0);
    stack_print(&data_stack, "After ALLOC");
  }
  else if(opcode == OP_CALL)
  {
    uint32_t frame_info = (data_stack.fp << 16) | (curr_pc + instruction_size_bytes);
    stack_push(&data_stack, frame_info);
    data_stack.fp = data_stack.sp + sizeof(uint32_t);
    stack_print(&data_stack, "CALL");
    exe->next_pc = payload;
  }
  else if(opcode == OP_RET)
  {
    stack_print(&data_stack, "RET");
    // stash return value
    uint32_t func_return_val;
    stack_pop(&data_stack, &func_return_val);
    // pop until frame_info is on TOS
    while(1)
    {
      if(data_stack.sp + sizeof(uint32_t) == data_stack.fp)
        break;
      stack_pop(&data_stack, NULL);
    }
    // pop frame_info and restore PC and FP
    uint32_t frame_info;
    stack_pop(&data_stack, &frame_info);
    data_stack.fp = (frame_info >> 16) & 0xffff;
    exe->next_pc = frame_info & 0xffff;
    // pop off arguments
    for (size_t i = 0; i < payload; i++)
      stack_pop(&data_stack, NULL);
    // push return value back on stack
    stack_push(&data_stack, func_return_val);
    stack_print(&data_stack, "UNWIND DONE");
  }
  else if(opcode == OP_HALT)
  {
    exe->result = EXE_HALT;
  }
  else if(opcode == OP_EQ)
  {
    binop(binop_equal);
  }
  else if(opcode == OP_NOTEQ)
  {
    binop(binop_not_equal);
  }
  else if(opcode == OP_LT)
  {
    binop(binop_lower);
  }
  else if(opcode == OP_LTE)
  {
    binop(binop_lower_eq);
  }
  else if(opcode == OP_GT)
  {
    binop(binop_greater);
  }
  else if(opcode == OP_GTE)
  {
    binop(binop_greater_eq);
  }
  else if(opcode == OP_ADD)
  {
    binop(binop_add);
  }
  else if(opcode == OP_SUB)
  {
    binop(binop_sub);
  }
  else if(opcode == OP_MULT)
  {
    binop(binop_mul);
  }
  else if(opcode == OP_DIV)
  {
    binop(binop_divide);
  }
  else if(opcode == OP_MOD)
  {
    binop(binop_mod);
  }
  else if(opcode == OP_POW)
  {
    binop(binop_power);
  }
  else if(opcode == OP_LSHIFT)
  {
    binop(binop_lshift);
  }
  else if(opcode == OP_RSHIFT)
  {
    binop(binop_rshift);
  }
  else if(opcode == OP_BITOR)
  {
    binop(binop_bitwise_or);
  }
  else if(opcode == OP_BITXOR)
  {
    binop(binop_bitwise_xor);
  }
  else if(opcode == OP_BITAND)
  {
    binop(binop_bitwise_and);
  }
  else if(opcode == OP_LOGIAND)
  {
    binop(binop_logical_and);
  }
  else if(opcode == OP_LOGIOR)
  {
    binop(binop_logical_or);
  }
  else if(opcode == OP_BITINV)
  {
    unaryop(unaop_bit_inv);
  }
  else if(opcode == OP_LOGINOT)
  {
    unaryop(unaop_logical_not);
  }
  else if(opcode == OP_USUB)
  {
    unaryop(unaop_usub);
  }
  else if(opcode == OP_DELAY)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    printf("OP_DELAY: %ldms\n", this_value);
  }
  else if(opcode == OP_KDOWN)
  {
    uint32_t combocode;
    stack_pop(&data_stack, &combocode);
    printf("OP_KDOWN: %ld\n", combocode);
  }
  else if(opcode == OP_KUP)
  {
    uint32_t combocode;
    stack_pop(&data_stack, &combocode);
    printf("OP_KUP: %ld\n", combocode);
  }
  else if(opcode == OP_MSCL)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    printf("OP_MSCL: %ld\n", this_value);
  }
  else if(opcode == OP_MMOV)
  {
    uint32_t tempx, tempy;
    stack_pop(&data_stack, &tempx);
    stack_pop(&data_stack, &tempy);
    printf("OP_MMOV: %ld %ld\n", tempx, tempy);
  }
  else if(opcode == OP_SWCF)
  {
    uint32_t red, green, blue;
    stack_pop(&data_stack, &red);
    stack_pop(&data_stack, &green);
    stack_pop(&data_stack, &blue);
    printf("OP_SWCF: %ld %ld %ld\n", red, green, blue);
    DS_SET_BITS(epilogue_actions, EPI_SAVE_COLOR_STATE);
  }
  else if(opcode == OP_SWCC)
  {
    uint32_t this_index, red, green, blue;
    stack_pop(&data_stack, &this_index);
    stack_pop(&data_stack, &red);
    stack_pop(&data_stack, &green);
    stack_pop(&data_stack, &blue);
    printf("OP_SWCC: %ld %ld %ld %ld\n", this_index, red, green, blue);
    DS_SET_BITS(epilogue_actions, EPI_SAVE_COLOR_STATE);
  }
  else if(opcode == OP_SWCR)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    printf("OP_SWCR: %ld\n", this_value);
    DS_CLEAR_BITS(epilogue_actions, EPI_SAVE_COLOR_STATE);
  }
  else if(opcode == OP_STR)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    char* str_buf = make_str((uint16_t)this_value);
    printf(">>>>> STRING: %s\n", str_buf);
  }
  else if(opcode == OP_STRLN)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    char* str_buf = make_str((uint16_t)this_value);
    printf(">>>>> STRINGLN: %s\n", str_buf);
  }
  else if(opcode == OP_OLED_CUSR)
  {
    uint32_t xxx, yyy;
    stack_pop(&data_stack, &xxx);
    stack_pop(&data_stack, &yyy);
    printf("OP_OLED_CUSR: %ld %ld\n", xxx, yyy);
  }
  else if(opcode == OP_OLED_PRNT)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    char* str_buf = make_str((uint16_t)this_value);
    printf(">>>>> OLED_PRINT: %s\n", str_buf);
  }
  else if(opcode == OP_OLED_UPDE)
  {
    printf("OP_OLED_UPDE\n");
    DS_SET_BITS(epilogue_actions, EPI_RESTORE_OLED);
  }
  else if(opcode == OP_OLED_CLR)
  {
    printf("OP_OLED_CLR\n");
  }
  else if(opcode == OP_OLED_REST)
  {
    printf("OP_OLED_REST\n");
    // user already restored OLED content, no need to do it again.
    DS_CLEAR_BITS(epilogue_actions, EPI_RESTORE_OLED);
  }
  else if(opcode == OP_OLED_LINE)
  {
    uint32_t x1,y1,x2,y2;
    stack_pop(&data_stack, &x1);
    stack_pop(&data_stack, &y1);
    stack_pop(&data_stack, &x2);
    stack_pop(&data_stack, &y2);
    printf("OP_OLED_LINE: %ld %ld %ld %ld\n", x1, y1, x2, y2);
  }
  else if(opcode == OP_OLED_RECT)
  {
    uint32_t x1,y1,x2,y2,fill;
    stack_pop(&data_stack, &x1);
    stack_pop(&data_stack, &y1);
    stack_pop(&data_stack, &x2);
    stack_pop(&data_stack, &y2);
    stack_pop(&data_stack, &fill);
    printf("OP_OLED_RECT: %ld %ld %ld %ld %ld\n", x1, y1, x2, y2, fill);
  }
  else if(opcode == OP_OLED_CIRC)
  {
    uint32_t x,y,radius,fill;
    stack_pop(&data_stack, &x);
    stack_pop(&data_stack, &y);
    stack_pop(&data_stack, &radius);
    stack_pop(&data_stack, &fill);
    printf("OP_OLED_CIRC: %ld %ld %ld %ld\n", x, y, radius, fill);
  }
  else if(opcode == OP_BCLR)
  {
    printf("OP_BCLR\n");
  }
  else if(opcode == OP_SKIPP)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    printf("OP_SKIPP: %ld\n", this_value);
  }
  else if(opcode == OP_GOTOP)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    char* str_buf = make_str((uint16_t)this_value);
    uint8_t is_int = str_is_integer(str_buf, NULL);
    printf("OP_GOTOP_STR %d: %s\n", is_int, str_buf);
  }
  else if(opcode == OP_SLEEP)
  {
    printf("OP_SLEEP\n");
  }
  else
  {
    printf("Unimplemented opcode: %d\n", opcode);
    longjmp(jmpbuf, EXE_ILLEGAL_INSTRUCTION);
  }
}

void run_dsb(exe_context* er, uint8_t this_key_id, char* dsb_path, uint8_t is_cached, uint8_t* dsb_cache)
{
  uint32_t this_dsb_size = 0;
  uint8_t dsb_load_result = load_dsb(dsb_path, &this_dsb_size);
  if(dsb_load_result)
  {
    printf("DSB load fail: %d\n", dsb_load_result);
    er->result = dsb_load_result;
    return;
  }

  uint16_t current_pc = 0;
  uint16_t data_stack_size_bytes = STACK_BASE_ADDR - this_dsb_size - STACK_MOAT_BYTES;
  stack_init(&data_stack, bin_buf, STACK_BASE_ADDR, data_stack_size_bytes);

  defaultdelay = DEFAULT_CMD_DELAY_MS;
  defaultchardelay = DEFAULT_CHAR_DELAY_MS;
  charjitter = 0;
  rand_max = 0xffffffff;
  rand_min = 0;
  loop_size = 0;
  epilogue_actions = 0;
  allow_abort = 0;
  disable_autorepeat = 0;
  str_print_format = STR_PRINT_FORMAT_DEC_SIGNED;
  str_print_padding = 0;

  int panic_code = setjmp(jmpbuf);
  if(panic_code != 0)
  {
    printf("VM Crashed! Panic: %d\n", panic_code);
    return;
  }
  while(1)
  {
    execute_instruction(current_pc, er);
    current_pc = er->next_pc;
    if(er->result != EXE_OK)
      break;
    if(current_pc > this_dsb_size)
      break;
  }
  printf("Execution Complete\n");
  disable_autorepeat ? DS_SET_BITS(epilogue_actions, EPI_NO_AUTOREPEAT) : DS_CLEAR_BITS(epilogue_actions, EPI_NO_AUTOREPEAT);
  printf("Epilogue: %02x\n", epilogue_actions);
}
