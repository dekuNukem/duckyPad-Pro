#include <stdio.h>    /* printf */
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include "esp_random.h"
#include "rotary_encoder.h"
#include "input_task.h"
#include "sd_task.h"
#include "ui_task.h"
#include "neopixel_task.h"
#include "shared.h"
#include "profiles.h"
#include "ssd1306.h"
#include "keypress_task.h"
#include "keyboard.h"
#include "ds_vm.h"
#include "input_task.h"
#include "dsb_cache.h"
#include "shared.h"
#include "hid_task.h"
#include <setjmp.h>
#include "esp_log.h"

static const char *TAG = "DSVM";

uint8_t bin_buf[BIN_BUF_SIZE] __attribute__((aligned(4))); // 0x0000 to 0xf7ff
uint8_t pgv_buf[PGV_BUF_SIZE] __attribute__((aligned(4))); // 0xfc00 to 0xfdff
uint8_t memIO_buf[MEMIO_BUF_SIZE] __attribute__((aligned(4))); // 0xff00 to 0xffff

uint32_t defaultdelay;
uint32_t defaultchardelay;
uint32_t charjitter;
uint32_t rand_min, rand_max;
uint32_t loop_size;
uint8_t* epilogue_ptr;
uint8_t allow_abort;
uint8_t kb_led_status;
uint8_t disable_autorepeat;
static jmp_buf jmpbuf;
uint8_t current_key_id = 127;

// ---------------------------


/*
  AUTO GENERATED BY
  print_C_opcode_len_lookup()
  print_C_opcode_def()
  IN dsvm_common.py
*/

#define OP_LEN_LOOKUP_SIZE 100
uint8_t opcode_len_lookup[OP_LEN_LOOKUP_SIZE] = {
1, // [0] NOP
3, // [1] PUSHC16
3, // [2] PUSHI
3, // [3] PUSHR
3, // [4] POPI
3, // [5] POPR
3, // [6] BRZ
3, // [7] JMP
3, // [8] ALLOC
3, // [9] CALL
3, // [10] RET
1, // [11] HALT
1, // [12] PUSH0
1, // [13] PUSH1
1, // [14] DROP
1, // [15] DUP
1, // [16] RANDINT
1, // [17] RANDUINT
5, // [18] PUSHC32
2, // [19] PUSHC8
255, // [20]
255, // [21]
255, // [22]
255, // [23]
1, // [24] PEEK8
1, // [25] PEEKU8
1, // [26] PEEK16
1, // [27] PEEKU16
1, // [28] PEEK32
1, // [29] POKE8
1, // [30] POKE16
1, // [31] POKE32
1, // [32] EQ
1, // [33] NOTEQ
1, // [34] LT
1, // [35] LTE
1, // [36] GT
1, // [37] GTE
1, // [38] ADD
1, // [39] SUB
1, // [40] MULT
1, // [41] DIV
1, // [42] MOD
1, // [43] POW
1, // [44] LSL
1, // [45] ASR
1, // [46] BITOR
1, // [47] BITXOR
1, // [48] BITAND
1, // [49] LOGIAND
1, // [50] LOGIOR
1, // [51] ULT
1, // [52] ULTE
1, // [53] UGT
1, // [54] UGTE
1, // [55] UDIV
1, // [56] UMOD
1, // [57] LSR
255, // [58]
255, // [59]
1, // [60] BITINV
1, // [61] LOGINOT
1, // [62] USUB
255, // [63]
1, // [64] DELAY
1, // [65] KDOWN
1, // [66] KUP
1, // [67] MSCL
1, // [68] MMOV
1, // [69] SWCF
1, // [70] SWCC
1, // [71] SWCR
1, // [72] STR
1, // [73] STRLN
1, // [74] OLED_CUSR
1, // [75] OLED_PRNT
1, // [76] OLED_UPDE
1, // [77] OLED_CLR
1, // [78] OLED_REST
1, // [79] OLED_LINE
1, // [80] OLED_RECT
1, // [81] OLED_CIRC
1, // [82] BCLR
1, // [83] SKIPP
1, // [84] GOTOP
1, // [85] SLEEP
1, // [86] RANDCHR
1, // [87] PUTS
1, // [88] HIDTX
255, // [89]
255, // [90]
255, // [91]
255, // [92]
255, // [93]
255, // [94]
255, // [95]
255, // [96]
255, // [97]
255, // [98]
255, // [99]
};

#define OP_NOP 0
#define OP_PUSHC16 1
#define OP_PUSHI 2
#define OP_PUSHR 3
#define OP_POPI 4
#define OP_POPR 5
#define OP_BRZ 6
#define OP_JMP 7
#define OP_ALLOC 8
#define OP_CALL 9
#define OP_RET 10
#define OP_HALT 11
#define OP_PUSH0 12
#define OP_PUSH1 13
#define OP_DROP 14
#define OP_DUP 15
#define OP_RANDINT 16
#define OP_RANDUINT 17
#define OP_PUSHC32 18
#define OP_PUSHC8 19
#define OP_PEEK8 24
#define OP_PEEKU8 25
#define OP_PEEK16 26
#define OP_PEEKU16 27
#define OP_PEEK32 28
#define OP_POKE8 29
#define OP_POKE16 30
#define OP_POKE32 31
#define OP_EQ 32
#define OP_NOTEQ 33
#define OP_LT 34
#define OP_LTE 35
#define OP_GT 36
#define OP_GTE 37
#define OP_ADD 38
#define OP_SUB 39
#define OP_MULT 40
#define OP_DIV 41
#define OP_MOD 42
#define OP_POW 43
#define OP_LSL 44
#define OP_ASR 45
#define OP_BITOR 46
#define OP_BITXOR 47
#define OP_BITAND 48
#define OP_LOGIAND 49
#define OP_LOGIOR 50
#define OP_ULT 51
#define OP_ULTE 52
#define OP_UGT 53
#define OP_UGTE 54
#define OP_UDIV 55
#define OP_UMOD 56
#define OP_LSR 57
#define OP_BITINV 60
#define OP_LOGINOT 61
#define OP_USUB 62
#define OP_DELAY 64
#define OP_KDOWN 65
#define OP_KUP 66
#define OP_MSCL 67
#define OP_MMOV 68
#define OP_SWCF 69
#define OP_SWCC 70
#define OP_SWCR 71
#define OP_STR 72
#define OP_STRLN 73
#define OP_OLED_CUSR 74
#define OP_OLED_PRNT 75
#define OP_OLED_UPDE 76
#define OP_OLED_CLR 77
#define OP_OLED_REST 78
#define OP_OLED_LINE 79
#define OP_OLED_RECT 80
#define OP_OLED_CIRC 81
#define OP_BCLR 82
#define OP_SKIPP 83
#define OP_GOTOP 84
#define OP_SLEEP 85
#define OP_RANDCHR 86
#define OP_PUTS 87
#define OP_HIDTX 88
#define OP_VMVER 255
// ---------------------------

my_stack data_stack;

// vm_stack_base: The virtual address where stack starts (e.g., 0xF7FF)
void stack_init(my_stack* ms, uint8_t* ram_base, uint16_t vm_stack_base, uint16_t size_bytes)
{
    // 1. Store the host memory base
    ms->ram_base = ram_base;

    // 2. Align the virtual base address (rounding down to nearest 4-byte boundary)
    //    If vm_stack_base is 0xF7FF, this becomes 0xF7FC
    uint16_t aligned_base = vm_stack_base & ~0x03;

    // 3. Set bounds
    ms->upper_bound = aligned_base; 
    ms->lower_bound = aligned_base - size_bytes;

    // 4. Initialize registers
    //    Matches your original logic: SP points to the current empty slot.
    //    We start "one slot down" so the first write occupies the top-most aligned bytes.
    ms->sp = ms->upper_bound - sizeof(uint32_t); 
    ms->fp = ms->upper_bound;

    // 5. Clear memory (Translation: Host Addr = ram_base + virtual_offset)
    memset(ms->ram_base + ms->lower_bound, 0, size_bytes);
}

void stack_push(my_stack* ms, uint32_t in_value)
{
  if (ms->sp < ms->lower_bound) 
    longjmp(jmpbuf, EXE_STACK_OVERFLOW);
  uint8_t* host_addr = ms->ram_base + ms->sp;
  memcpy(host_addr, &in_value, sizeof(uint32_t));
  ms->sp -= sizeof(uint32_t);
}

void stack_pop(my_stack* ms, uint32_t *out_value)
{
  uint16_t next_sp = ms->sp + sizeof(uint32_t);
  if (next_sp >= ms->upper_bound)
    longjmp(jmpbuf, EXE_STACK_UNDERFLOW);
  ms->sp = next_sp;
  uint8_t* host_addr = ms->ram_base + ms->sp;
  if(out_value != NULL)
    memcpy(out_value, host_addr, sizeof(uint32_t));
}

uint32_t stack_peek(my_stack* ms)
{
  // The 'top' of the stack is 4 bytes above the current SP
  uint16_t top_address = ms->sp + sizeof(uint32_t);

  // Check if the stack is empty (Underflow)
  if (top_address >= ms->upper_bound)
    longjmp(jmpbuf, EXE_STACK_UNDERFLOW);

  // Calculate host address and return the value
  uint32_t value;
  uint8_t* host_addr = ms->ram_base + top_address;
  memcpy(&value, host_addr, sizeof(uint32_t));
  
  return value;
}

void stack_write_fp_rel(my_stack* ms, int16_t offset, uint32_t value)
{
  if (offset & 0x03)
    longjmp(jmpbuf, EXE_UNALIGNED_ACCESS);
  uint16_t target_addr = ms->fp + offset;
  if (target_addr < ms->lower_bound || target_addr > (ms->upper_bound - sizeof(uint32_t)))
    longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
  uint8_t* host_addr = ms->ram_base + target_addr;
  memcpy(host_addr, &value, sizeof(uint32_t));
}

void stack_read_fp_rel(my_stack* ms, int16_t offset, uint32_t* value)
{
  if (offset & 0x03)
    longjmp(jmpbuf, EXE_UNALIGNED_ACCESS);

  uint16_t target_addr = ms->fp + offset;
  if (target_addr < ms->lower_bound || target_addr > (ms->upper_bound - sizeof(uint32_t)))
    longjmp(jmpbuf, EXE_ILLEGAL_ADDR);

  uint8_t* host_addr = ms->ram_base + target_addr;
  memcpy(value, host_addr, sizeof(uint32_t));
}

uint32_t binop_unsigned_lt(uint32_t a, uint32_t b){return a < b;}
uint32_t binop_unsigned_lte(uint32_t a, uint32_t b){return a <= b;}
uint32_t binop_unsigned_greater(uint32_t a, uint32_t b){return a > b;}
uint32_t binop_unsigned_greater_eq(uint32_t a, uint32_t b){return a >= b;}

uint32_t binop_equal(uint32_t a, uint32_t b) {return a == b;}
uint32_t binop_not_equal(uint32_t a, uint32_t b) {return a != b;}
uint32_t binop_signed_lt(uint32_t a, uint32_t b){return (int32_t)a < (int32_t)b;}
uint32_t binop_signed_lte(uint32_t a, uint32_t b){return (int32_t)a <= (int32_t)b;}
uint32_t binop_signed_greater(uint32_t a, uint32_t b){return (int32_t)a > (int32_t)b;}
uint32_t binop_signed_greater_eq(uint32_t a, uint32_t b){return (int32_t)a >= (int32_t)b;}
uint32_t binop_add(uint32_t a, uint32_t b) {return a + b;}
uint32_t binop_sub(uint32_t a, uint32_t b) {return a - b;}
uint32_t binop_mul(uint32_t a, uint32_t b) {return a * b;}
uint32_t binop_singed_mod(uint32_t a, uint32_t b)
{
  if(b == 0)
    longjmp(jmpbuf, EXE_DIVISION_BY_ZERO);
  return (int32_t)a % (int32_t)b;
}
uint32_t binop_unsinged_mod(uint32_t a, uint32_t b)
{
  if(b == 0)
    longjmp(jmpbuf, EXE_DIVISION_BY_ZERO);
  return a % b;
}
uint32_t binop_lshift(uint32_t a, uint32_t b) {return a << b;}
uint32_t binop_signed_rshift(uint32_t a, uint32_t b){return (int32_t)((int32_t)a >> (int32_t)b);}
uint32_t binop_unsigned_rshift(uint32_t a, uint32_t b){return a >> b;}
uint32_t binop_bitwise_or(uint32_t a, uint32_t b) {return a | b;}
uint32_t binop_bitwise_xor(uint32_t a, uint32_t b) {return a ^ b;}
uint32_t binop_bitwise_and(uint32_t a, uint32_t b) {return a & b;}
uint32_t binop_logical_and(uint32_t a, uint32_t b) {return a && b;}
uint32_t binop_logical_or(uint32_t a, uint32_t b) {return a || b;}
uint32_t binop_signed_divide(uint32_t lhs, uint32_t rhs)
{
  if(rhs == 0)
    longjmp(jmpbuf, EXE_DIVISION_BY_ZERO);
  return (int32_t)lhs / (int32_t)rhs; 
}
uint32_t binop_unsigned_divide(uint32_t lhs, uint32_t rhs)
{
  if(rhs== 0)
    longjmp(jmpbuf, EXE_DIVISION_BY_ZERO);
  return lhs / rhs; 
}
uint32_t binop_powerof(uint32_t x, uint32_t exponent)
{
  if((int32_t)exponent < 0)
    return 0;
  int32_t result = 1;
  for (size_t i = 0; i < exponent; ++i)
    result *= x;
  return result;
}

uint32_t unaop_bit_inv(uint32_t value) {return ~value;}
uint32_t unaop_logical_not(uint32_t value) {return !value;}
uint32_t unaop_usub(uint32_t value) {return value * -1;}

void binop(FUNC_PTR_BINOP bin_func)
{
  uint32_t lhs, rhs;
  stack_pop(&data_stack, &lhs);
  stack_pop(&data_stack, &rhs);
  stack_push(&data_stack, bin_func(lhs, rhs));
}

void unaryop(FUNC_PTR_UNARY una_func)
{
  uint32_t value;
  stack_pop(&data_stack, &value);
  stack_push(&data_stack, una_func(value));
}


void write_bytes_safe(uint32_t vm_addr, const void* src, size_t size)
{
  if (vm_addr <= SCRATCH_MEM_END_ADDRESS_INCLUSIVE)
  {
    if (vm_addr + size > BIN_BUF_SIZE)
      longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
    memcpy(&bin_buf[vm_addr], src, size);
    return;
  }

  if (vm_addr >= PGV_START_ADDRESS && vm_addr <= PGV_END_ADDRESS_INCLUSIVE)
  {
    uint32_t offset = vm_addr - PGV_START_ADDRESS;
    if (offset + size > PGV_BUF_SIZE)
      longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
    memcpy(&pgv_buf[offset], src, size);
    DS_SET_BITS(*epilogue_ptr, EPILOGUE_SAVE_PGV);
    return;
  }

  if (vm_addr >= MEMIO_START_ADDRESS && vm_addr <= MEMIO_END_ADDRESS_INCLUSIVE)
  {
    uint32_t offset = vm_addr - MEMIO_START_ADDRESS;
    if (offset + size > MEMIO_BUF_SIZE)
      longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
    memcpy(&memIO_buf[offset], src, size);
    return;
  }

  longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
}

void read_bytes_safe(uint32_t vm_addr, void* dest, size_t size)
{
  if (vm_addr <= SCRATCH_MEM_END_ADDRESS_INCLUSIVE)
  {
    if (vm_addr + size > BIN_BUF_SIZE)
      longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
    memcpy(dest, &bin_buf[vm_addr], size);
    return;
  }

  if (vm_addr >= PGV_START_ADDRESS && vm_addr <= PGV_END_ADDRESS_INCLUSIVE)
  {
    uint32_t offset = vm_addr - PGV_START_ADDRESS;
    if (offset + size > PGV_BUF_SIZE)
      longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
    memcpy(dest, &pgv_buf[offset], size);
    return;
  }

  if (vm_addr >= MEMIO_START_ADDRESS && vm_addr <= MEMIO_END_ADDRESS_INCLUSIVE)
  {
    uint32_t offset = vm_addr - MEMIO_START_ADDRESS;
    if (offset + size > MEMIO_BUF_SIZE)
      longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
    memcpy(dest, &memIO_buf[offset], size);
    return;
  }

  longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
}

uint8_t readkey_nonblocking_1_indexed(void)
{
  for (uint8_t i = 0; i < MAX_TOTAL_SW_COUNT; i++)
  {
    if(poll_sw_state(i, 0))
      return i+1;
  }
  return 0;
}

uint8_t readkey_blocking_1_indexed(void)
{
  switch_event_t sw_event;
  rotary_encoder_event_t re_event;
  clear_sw_re_queue();
  while(1)
  {
    delay_ms(1);
    if(xQueueReceive(rotary_encoder_event_queue, &re_event, 0))
      return re_event_to_swid(&re_event)+1;
    if(xQueueReceive(switch_event_queue, &sw_event, 0) && sw_event.type == SW_EVENT_SHORT_PRESS)
      return sw_event.id+1;
  }
}

uint16_t get_rtc_data(uint16_t addr)
{
  struct tm local_tm;
  get_local_time(utc_offset_minutes, &local_tm);
  if(addr == _RTC_YEAR)
    return local_tm.tm_year + 1900;
  if(addr == _RTC_MONTH)
    return local_tm.tm_mon + 1;
  if(addr == _RTC_DAY)
    return local_tm.tm_mday;
  if(addr == _RTC_HOUR)
    return local_tm.tm_hour;
  if(addr == _RTC_MINUTE)
    return local_tm.tm_min;
  if(addr == _RTC_SECOND)
    return local_tm.tm_sec;
  if(addr == _RTC_WDAY)
    return local_tm.tm_wday;
  if(addr == _RTC_YDAY)
    return local_tm.tm_yday;
  return 0;
}

uint32_t memread_u32(uint16_t vm_addr)
{
  if (vm_addr == _DEFAULTDELAY)
	  return defaultdelay;
  if (vm_addr == _DEFAULTCHARDELAY)
    return defaultchardelay;
  if (vm_addr == _CHARJITTER)
    return charjitter;
  if (vm_addr == _RANDOM_MIN)
    return rand_min;
  if (vm_addr == _RANDOM_MAX)
    return rand_max;
  if (vm_addr == _RANDOM_INT)
    return (uint32_t)random_int32_between((int32_t)rand_min, (int32_t)rand_max);
  if (vm_addr == _TIME_MS)
    return millis();
  if (vm_addr == _READKEY)
    return readkey_nonblocking_1_indexed();
  if (vm_addr == _LOOP_SIZE)
    return loop_size;
  if (vm_addr == _KEYPRESS_COUNT)
    return all_profile_info[current_profile_number].keypress_count[current_key_id];
  if (vm_addr == _EPILOGUE_ACTIONS)
    return *epilogue_ptr;
  if (vm_addr == _TIME_S)
    return millis()/1000;
  if (vm_addr == _ALLOW_ABORT)
    return allow_abort;
  if (vm_addr == _BLOCKING_READKEY)
    return readkey_blocking_1_indexed();
  if (vm_addr == _KBLED_BITFIELD)
    return kb_led_status;
  if (vm_addr == _DONT_REPEAT)
    return disable_autorepeat;
  if (vm_addr == _THIS_KEYID)
    return current_key_id;
  if (vm_addr == _DP_MODEL)
    return 2;
  if (vm_addr == _RTC_IS_VALID)
    return is_rtc_valid;
  if (vm_addr == _RTC_UTC_OFFSET)
    return utc_offset_minutes;
  if (vm_addr >= _RTC_YEAR && vm_addr <= _RTC_YDAY)
    return get_rtc_data(vm_addr);
  if (vm_addr == _UNUSED)
    return 0;
  if (vm_addr == _SW_BITFIELD)
    return get_sw_state_bitfield();
  uint32_t value;
  read_bytes_safe(vm_addr, &value, sizeof(value));
  return value;
}

void memwrite_u32(uint16_t vm_addr, uint32_t value)
{
  if (vm_addr == _DEFAULTDELAY)
	  defaultdelay = value;
  else if (vm_addr == _DEFAULTCHARDELAY)
    defaultchardelay = value;
  else if (vm_addr == _CHARJITTER)
    charjitter = value;
  else if (vm_addr == _RANDOM_MIN)
    rand_min = value;
  else if (vm_addr == _RANDOM_MAX)
    rand_max = value;
  else if (vm_addr == _LOOP_SIZE)
    loop_size = value;
  else if (vm_addr == _KEYPRESS_COUNT)
    all_profile_info[current_profile_number].keypress_count[current_key_id] = value;
  else if (vm_addr == _EPILOGUE_ACTIONS)
    *epilogue_ptr = value;
  else if (vm_addr == _ALLOW_ABORT)
    allow_abort = value;
  else if (vm_addr == _DONT_REPEAT)
    disable_autorepeat = value;
  else if (vm_addr == _RTC_UTC_OFFSET)
    utc_offset_minutes = value;
  else
    write_bytes_safe(vm_addr, &value, sizeof(value));
}

uint8_t load_dsb(char* dsb_path, uint32_t* dsb_size)
{
  FILE *dsb_file = fopen(dsb_path, "rb");
  if(dsb_file == NULL)
    return EXE_DSB_FOPEN_FAIL;
  memset(bin_buf, 0, BIN_BUF_SIZE);
  *dsb_size = fread(bin_buf, 1, BIN_BUF_SIZE, dsb_file);
  fclose(dsb_file);
  if(*dsb_size == 0)
    return EXE_DSB_FREAD_ERROR;
  if(*dsb_size >= MAX_BIN_SIZE)
    return EXE_DSB_FILE_TOO_LARGE;
  if(bin_buf[0] != OP_VMVER)
    return EXE_DSB_INCOMPATIBLE_VERSION;
  if(bin_buf[1] != dsvm_version)
    return EXE_DSB_INCOMPATIBLE_VERSION;
  return EXE_OK;
}

uint8_t str_is_integer(const char *str, long *out_value)
{
  char *endptr;
  long val = strtol(str, &endptr, 0);
  if (str == endptr)
    return 0;
  if (*endptr != '\0')
    return 0;
  if (out_value)
    *out_value = val;    
  return 1;
}

int8_t lookup_profile_index(const char* identifier)
{
  int32_t pf_int = -1;
  if (str_is_integer(identifier, &pf_int))
    if (pf_int >= 0 && pf_int < MAX_PROFILES && all_profile_info[pf_int].is_loaded)
      return (int8_t)pf_int;
  for (uint8_t i = 0; i < MAX_PROFILES; i++)
    if (all_profile_info[i].is_loaded && strcmp(identifier, all_profile_info[i].pf_name) == 0)
      return (int8_t)i;
  return -1;
}

uint8_t inst_size_lookup(uint8_t opcode)
{
  if(opcode == OP_VMVER)
    return 3;
  if(opcode >= OP_LEN_LOOKUP_SIZE || opcode_len_lookup[opcode] > MAX_INSTRUCTION_LEN)
    longjmp(jmpbuf, EXE_ILLEGAL_INSTRUCTION);
  return opcode_len_lookup[opcode];
}

void my_snprintf(const char* format, uint32_t value, char* buf, uint32_t buf_size)
{
  if (buf == NULL || buf_size == 0)
    return;
  if (format == NULL || strlen(format) == 0)
    snprintf(buf, buf_size, "%ld", (int32_t)value);
  else 
    snprintf(buf, buf_size, format, value);
}

char* copy_format_specifier(char* src, char* spec_buf, uint8_t spec_buf_size, uint8_t boundary)
{
  memset(spec_buf, 0, spec_buf_size);
  uint8_t i = 0;
  while(1)
  {
    if(src[i] == 0)
      return NULL;
    if(i >= spec_buf_size)
      return NULL;
    if((uint8_t)src[i] == boundary)
      return &src[i];
    spec_buf[i] = src[i];
    i++;
  }
  return NULL;
}

#define MKSTR_BUF_SIZE 32
char make_str_buf[MKSTR_BUF_SIZE];
#define READ_BUF_SIZE (256 * 4)
char read_buffer[READ_BUF_SIZE];
#define FORMAT_SPEC_BUF_SIZE 16
char format_spec_buf[FORMAT_SPEC_BUF_SIZE];

char* make_str(uint16_t str_start_addr)
{
  char* curr_char = (char*)(bin_buf + str_start_addr);
  memset(read_buffer, 0, READ_BUF_SIZE);
  char* write_ptr = read_buffer;
  const char* buffer_end = read_buffer + READ_BUF_SIZE - 1; // Leave room for null terminator

  while (*curr_char != 0)
  {
    if (*curr_char == MAKESTR_VAR_BOUNDARY_IMM || *curr_char == MAKESTR_VAR_BOUNDARY_REL)
    {
      uint8_t boundary_type = *curr_char;
      curr_char++; // At LSB
      uint8_t* lsb = (uint8_t*)curr_char;
      curr_char++; // At MSB
      curr_char++; // At format specifier or closing boundary
      
      // Handle Format Specifier
      memset(format_spec_buf, 0, FORMAT_SPEC_BUF_SIZE);
      if (*curr_char != boundary_type)
      {
        curr_char = copy_format_specifier(curr_char, format_spec_buf, FORMAT_SPEC_BUF_SIZE, boundary_type);
        if (curr_char == NULL)
          longjmp(jmpbuf, EXE_STR_ERROR);
      }
      curr_char++; // closing boundary

      uint16_t addr_val;
      memcpy(&addr_val, lsb, sizeof(addr_val)); 
      uint32_t var_value = 0;

      // Fetch the value based on the boundary type
      if (boundary_type == MAKESTR_VAR_BOUNDARY_IMM)
        var_value = memread_u32(addr_val);
      else
        stack_read_fp_rel(&data_stack, (int16_t)addr_val, &var_value);

      memset(make_str_buf, 0, MKSTR_BUF_SIZE);
      my_snprintf(format_spec_buf, var_value, make_str_buf, MKSTR_BUF_SIZE);
      
      size_t added_len = strlen(make_str_buf);
      if (write_ptr + added_len >= buffer_end)
          longjmp(jmpbuf, EXE_STR_ERROR);
        
      memcpy(write_ptr, make_str_buf, added_len);
      write_ptr += added_len;
      continue;
    }

    if (write_ptr >= buffer_end)
      longjmp(jmpbuf, EXE_STR_ERROR);

    *write_ptr++ = *curr_char;
    curr_char++;
  }

  *write_ptr = '\0';
  return read_buffer;
}

#define RANDCHR_LOWER (1 << 0) // 1
#define RANDCHR_UPPER (1 << 1) // 2
#define RANDCHR_DIGITS (1 << 2) // 4
#define RANDCHR_SYMBOLS (1 << 3) // 8
#define RANDCHR_PRINT_KB (1 << 0) // 1
#define RANDCHR_PRINT_OLED (1 << 1) // 2

const char* chr_upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const char* chr_lower = "abcdefghijklmnopqrstuvwxyz";
const char* chr_nums  = "0123456789";
const char* chr_syms  = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}";
#define RANDCHAR_POOL_SIZE 128
char randchar_pool[RANDCHAR_POOL_SIZE];

char get_random_char(uint8_t bitmask)
{
  memset(randchar_pool, 0, RANDCHAR_POOL_SIZE);
  if (bitmask & RANDCHR_UPPER) strcat(randchar_pool, chr_upper);
  if (bitmask & RANDCHR_LOWER) strcat(randchar_pool, chr_lower);
  if (bitmask & RANDCHR_DIGITS) strcat(randchar_pool, chr_nums);
  if (bitmask & RANDCHR_SYMBOLS) strcat(randchar_pool, chr_syms);
  uint32_t pool_size = strlen(randchar_pool);
  if (pool_size == 0)
    return 0;
  return randchar_pool[rand() % pool_size];
}

uint32_t my_randu32(void)
{
  return esp_random();
}

uint32_t myrandu32_uniform(uint32_t range)
{
  return range ? my_randu32() % range : 0;
}

uint32_t random_uint32_between(uint32_t lower, uint32_t upper)
{
  if (lower > upper) { uint32_t tmp = lower; lower = upper; upper = tmp; }
  uint64_t range = (uint64_t)upper - (uint64_t)lower + 1;
  if (range >> 32) 
    return my_randu32(); 
  return lower + myrandu32_uniform((uint32_t)range);
}

int32_t random_int32_between(int32_t lower, int32_t upper)
{
  if (lower > upper) { int32_t tmp = lower; lower = upper; upper = tmp; }
  int64_t range = (int64_t)upper - (int64_t)lower + 1;
  if (range >= 0x100000000LL)
    return (int32_t)my_randu32();
  return lower + (int32_t)myrandu32_uniform((uint32_t)range);
}

uint8_t delayms_check_abort(uint32_t amount)
{
  for (uint32_t i = 0; i < amount; i++)
  {
    if(allow_abort && sw_queue_has_keydown_event())
      return 1;
    delay_ms(1);
  }
  return 0;
}

void oled_centre_print_preserve_cursor(char* text_buf)
{
  uint8_t oldx, oldy;
  ssd1306_GetCursor(&oldx, &oldy);
  ssd1306_SetCursor(center_line(strlen(text_buf), 7, SSD1306_WIDTH), oldy);
  ssd1306_WriteString(text_buf, Font_7x10, White);
  ssd1306_SetCursor(oldx, oldy);
}

void parse_swcf(void)
{
  uint32_t red, green, blue;
  stack_pop(&data_stack, &red);
  stack_pop(&data_stack, &green);
  stack_pop(&data_stack, &blue);
  for (size_t i = 0; i < NEOPIXEL_COUNT; i++)
  {
    all_profile_info[current_profile_number].has_user_assigned_keycolor[i] = 1;
    all_profile_info[current_profile_number].sw_color_user_assigned[i][RED] = (uint8_t)red;
    all_profile_info[current_profile_number].sw_color_user_assigned[i][GREEN] = (uint8_t)green;
    all_profile_info[current_profile_number].sw_color_user_assigned[i][BLUE] = (uint8_t)blue;
  }
  redraw_bg(current_profile_number);
  DS_SET_BITS(*epilogue_ptr, EPILOGUE_SAVE_COLOR_STATE);
}

void parse_swcc(void)
{
  uint32_t this_index, red, green, blue;
  stack_pop(&data_stack, &this_index);
  stack_pop(&data_stack, &red);
  stack_pop(&data_stack, &green);
  stack_pop(&data_stack, &blue);
  if(this_index == 0)
    this_index = current_key_id;
  else
    this_index--;
  if(this_index >= NEOPIXEL_COUNT)
    return;
  all_profile_info[current_profile_number].has_user_assigned_keycolor[this_index] = 1;
  all_profile_info[current_profile_number].sw_color_user_assigned[this_index][RED] = (uint8_t)red;
  all_profile_info[current_profile_number].sw_color_user_assigned[this_index][GREEN] = (uint8_t)green;
  all_profile_info[current_profile_number].sw_color_user_assigned[this_index][BLUE] = (uint8_t)blue;
  redraw_bg(current_profile_number);
  DS_SET_BITS(*epilogue_ptr, EPILOGUE_SAVE_COLOR_STATE);
}

void parse_swcr(void)
{
  uint32_t this_value;
  stack_pop(&data_stack, &this_value);

  if(this_value == 0)
    this_value = current_key_id;
  else
    this_value--;

  if(this_value >= NEOPIXEL_COUNT)
  {
    for (size_t i = 0; i < NEOPIXEL_COUNT; i++)
      all_profile_info[current_profile_number].has_user_assigned_keycolor[i] = 0;
  }
  else
  {
    all_profile_info[current_profile_number].has_user_assigned_keycolor[this_value] = 0;
  }
  redraw_bg(current_profile_number);
  DS_SET_BITS(*epilogue_ptr, EPILOGUE_SAVE_COLOR_STATE);
}

void expand_mmov(int16_t xtotal, int16_t ytotal)
{
  int16_t xsign = (xtotal < 0) ? -1 : 1;
  int16_t ysign = (ytotal < 0) ? -1 : 1;

  xtotal = abs(xtotal);
  ytotal = abs(ytotal);

  uint8_t loops_needed_x = abs(xtotal) / 128;
  uint8_t loops_needed_y = abs(ytotal) / 128;

  uint8_t total_loops_needed = MAX(loops_needed_x, loops_needed_y);

  for (int i = 0; i <= total_loops_needed; ++i)
  {
    int8_t this_x_amount;
    if(xtotal > 127)
      this_x_amount = 127;
    else
      this_x_amount = xtotal;
    xtotal -= this_x_amount;

    int8_t this_y_amount;
    if(ytotal > 127)
      this_y_amount = 127;
    else
      this_y_amount = ytotal;
    ytotal -= this_y_amount;

    my_key kk;
    kk.code = (uint8_t)this_x_amount*xsign;
    kk.code2 = (uint8_t)this_y_amount*ysign;
    kk.type = KEY_TYPE_MOUSE_MOVEMENT;
    action_press(&kk, 0);
    delay_ms(defaultdelay);
  }
}

void clamp_uint(uint32_t* value, uint32_t upper_limit)
{
  if(value == NULL)
    return;
  if(*value > upper_limit)
    *value = upper_limit;
}

void execute_instruction(exe_context* exe)
{
  uint16_t curr_pc = exe->this_pc;
  uint32_t opcode = 0;
  read_bytes_safe(curr_pc, &opcode, 1);
  opcode &= 0xff;
  uint8_t instruction_size_bytes = inst_size_lookup(opcode);
  uint32_t payload = 0;
  exe->next_pc += instruction_size_bytes;
  
  if(instruction_size_bytes == 2)
    payload = bin_buf[curr_pc + 1];
  else if(instruction_size_bytes == 3)
    read_bytes_safe(curr_pc + 1, &payload, sizeof(uint16_t));
  else if(instruction_size_bytes == 5)
    read_bytes_safe(curr_pc + 1, &payload, sizeof(uint32_t));

  if(opcode == OP_NOP || opcode == OP_VMVER)
  {
    return;
  }
  else if(opcode == OP_PUSHC8 || opcode == OP_PUSHC16 || opcode == OP_PUSHC32)
  {
    stack_push(&data_stack, payload);
  }
  else if(opcode == OP_PUSHI)
  {
    stack_push(&data_stack, memread_u32(payload));
  }
  else if(opcode == OP_PUSHR)
  {
    uint32_t this_value;
    stack_read_fp_rel(&data_stack, (int16_t)payload, &this_value);
    stack_push(&data_stack, this_value);
  }
  else if(opcode == OP_POPI)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    memwrite_u32(payload, this_value);
  }
  else if(opcode == OP_POPR)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    stack_write_fp_rel(&data_stack, (int16_t)payload, this_value);
  }
  else if(opcode == OP_BRZ)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    if(this_value == 0)
      exe->next_pc = payload;
  }
  else if(opcode == OP_JMP)
  {
    exe->next_pc = payload;
  }
  else if(opcode == OP_ALLOC)
  {
    for (size_t i = 0; i < payload; i++)
      stack_push(&data_stack, 0);
  }
  else if(opcode == OP_CALL)
  {
    uint32_t frame_info = (data_stack.fp << 16) | (curr_pc + instruction_size_bytes);
    stack_push(&data_stack, frame_info);
    data_stack.fp = data_stack.sp + sizeof(uint32_t);
    exe->next_pc = payload;
  }
  else if(opcode == OP_RET)
  {
    // stash return value
    uint32_t func_return_val;
    stack_pop(&data_stack, &func_return_val);
    // pop until frame_info is on TOS
    while(1)
    {
      if(data_stack.sp + sizeof(uint32_t) == data_stack.fp)
        break;
      stack_pop(&data_stack, NULL);
    }
    // pop frame_info and restore PC and FP
    uint32_t frame_info;
    stack_pop(&data_stack, &frame_info);
    data_stack.fp = (frame_info >> 16) & 0xffff;
    exe->next_pc = frame_info & 0xffff;
    // pop off arguments
    for (size_t i = 0; i < payload; i++)
      stack_pop(&data_stack, NULL);
    // push return value back on stack
    stack_push(&data_stack, func_return_val);
  }
  else if(opcode == OP_HALT)
  {
    exe->result = EXE_HALT;
  }
  else if(opcode == OP_PUSH0)
  {
    stack_push(&data_stack, 0);
  }
  else if(opcode == OP_PUSH1)
  {
    stack_push(&data_stack, 1);
  }
  else if(opcode == OP_DROP)
  {
    stack_pop(&data_stack, NULL);
  }
  else if(opcode == OP_DUP)
  {
    uint32_t topval = stack_peek(&data_stack);
    stack_push(&data_stack, topval);
  }
  else if(opcode == OP_RANDINT) // signed
  {
    uint32_t lower, upper;
    stack_pop(&data_stack, &lower);
    stack_pop(&data_stack, &upper);
    stack_push(&data_stack, (uint32_t)random_int32_between(lower, upper));
  }
  else if(opcode == OP_RANDUINT) // unsigned
  {
    uint32_t lower, upper;
    stack_pop(&data_stack, &lower);
    stack_pop(&data_stack, &upper);
    stack_push(&data_stack, random_uint32_between(lower, upper));
  }
  // -------- Memory Access ----------
  else if (opcode == OP_PEEK8)
  {
    uint32_t addr;
    stack_pop(&data_stack, &addr);
    int8_t val;
    read_bytes_safe(addr, &val, 1);
    stack_push(&data_stack, (int32_t)val);
  }
  else if (opcode == OP_PEEKU8)
  {
    uint32_t addr;
    stack_pop(&data_stack, &addr);
    uint8_t val;
    read_bytes_safe(addr, &val, 1);
    stack_push(&data_stack, (uint32_t)val);
  }
  else if (opcode == OP_PEEK16)
  {
    uint32_t addr;
    stack_pop(&data_stack, &addr);
    int16_t val;
    read_bytes_safe(addr, &val, 2);
    stack_push(&data_stack, (int32_t)val);
  }
  else if (opcode == OP_PEEKU16)
  {
    uint32_t addr;
    stack_pop(&data_stack, &addr);
    uint16_t val;
    read_bytes_safe(addr, &val, 2);
    stack_push(&data_stack, (uint32_t)val);
  }
  else if (opcode == OP_PEEK32)
  {
    uint32_t addr;
    stack_pop(&data_stack, &addr);
    uint32_t val;
    read_bytes_safe(addr, &val, 4);
    stack_push(&data_stack, val);
  }
  else if (opcode == OP_POKE8)
  {
    uint32_t addr, val;
    stack_pop(&data_stack, &addr);
    stack_pop(&data_stack, &val);
    uint8_t val8 = (uint8_t)val;
    write_bytes_safe(addr, &val8, 1);
  }
  else if (opcode == OP_POKE16)
  {
    uint32_t addr, val;
    stack_pop(&data_stack, &addr);
    stack_pop(&data_stack, &val);
    uint16_t val16 = (uint16_t)val;
    write_bytes_safe(addr, &val16, 2);
  }
  else if (opcode == OP_POKE32)
  {
    uint32_t addr, val;
    stack_pop(&data_stack, &addr);
    stack_pop(&data_stack, &val);
    write_bytes_safe(addr, &val, 4);
  }
  //--------------------------------------------------------
  else if(opcode == OP_EQ)
  {
    binop(binop_equal);
  }
  else if(opcode == OP_NOTEQ)
  {
    binop(binop_not_equal);
  }
  else if(opcode == OP_LT)
  {
    binop(binop_signed_lt);
  }
  else if(opcode == OP_LTE)
  {
    binop(binop_signed_lte);
  }
  else if(opcode == OP_GT)
  {
    binop(binop_signed_greater);
  }
  else if(opcode == OP_GTE)
  {
    binop(binop_signed_greater_eq);
  }
  else if(opcode == OP_ADD)
  {
    binop(binop_add);
  }
  else if(opcode == OP_SUB)
  {
    binop(binop_sub);
  }
  else if(opcode == OP_MULT)
  {
    binop(binop_mul);
  }
  else if(opcode == OP_DIV)
  {
    binop(binop_signed_divide);
  }
  else if(opcode == OP_MOD)
  {
    binop(binop_singed_mod);
  }
  else if(opcode == OP_POW)
  {
    binop(binop_powerof);
  }
  else if(opcode == OP_LSL)
  {
    binop(binop_lshift);
  }
  else if(opcode == OP_ASR)
  {
    binop(binop_signed_rshift);
  }
  else if(opcode == OP_BITOR)
  {
    binop(binop_bitwise_or);
  }
  else if(opcode == OP_BITXOR)
  {
    binop(binop_bitwise_xor);
  }
  else if(opcode == OP_BITAND)
  {
    binop(binop_bitwise_and);
  }
  else if(opcode == OP_LOGIAND)
  {
    binop(binop_logical_and);
  }
  else if(opcode == OP_LOGIOR)
  {
    binop(binop_logical_or);
  }
  //--------Unsigned Funcs-----------
  else if (opcode == OP_ULT)
  {
    binop(binop_unsigned_lt);
  }
  else if (opcode == OP_ULTE)
  {
    binop(binop_unsigned_lte);
  }
  else if (opcode == OP_UGT)
  {
    binop(binop_unsigned_greater);
  }
  else if (opcode == OP_UGTE)
  {
    binop(binop_unsigned_greater_eq);
  }
  else if (opcode == OP_UDIV)
  {
    binop(binop_unsigned_divide);
  }
  else if (opcode == OP_UMOD)
  {
    binop(binop_unsinged_mod);
  }
  else if (opcode == OP_LSR)
  {
    binop(binop_unsigned_rshift);
  }
  //---------Unary Ops----------
  else if(opcode == OP_BITINV)
  {
    unaryop(unaop_bit_inv);
  }
  else if(opcode == OP_LOGINOT)
  {
    unaryop(unaop_logical_not);
  }
  else if(opcode == OP_USUB)
  {
    unaryop(unaop_usub);
  }
  else if(opcode == OP_DELAY)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    if(delayms_check_abort(this_value))
    {
      exe->result = EXE_ABORTED;
      return;
    }
  }
  else if(opcode == OP_KDOWN)
  {
    uint32_t combocode;
    stack_pop(&data_stack, &combocode);
    uint8_t ktype = (combocode >> 8) & 0xff;
    uint8_t kcode = combocode & 0xff;
  	press_key(kcode, ktype);
  	delay_ms(defaultdelay);
  }
  else if(opcode == OP_KUP)
  {
    uint32_t combocode;
    stack_pop(&data_stack, &combocode);
    uint8_t ktype = (combocode >> 8) & 0xff;
    uint8_t kcode = combocode & 0xff;
  	release_key(kcode, ktype);
  	delay_ms(defaultdelay);
  }
  else if(opcode == OP_MSCL)
  {
    uint32_t hlines, vlines;
    stack_pop(&data_stack, &hlines);
    stack_pop(&data_stack, &vlines);
    my_key kk;
    kk.code = vlines;
    kk.code2 = hlines;
    kk.type = KEY_TYPE_MOUSE_WHEEL;
    action_press(&kk, 0);
    delay_ms(defaultdelay);
    action_release(&kk);
    delay_ms(defaultdelay);
  }
  else if(opcode == OP_MMOV)
  {
    uint32_t tempx, tempy;
    stack_pop(&data_stack, &tempx);
    stack_pop(&data_stack, &tempy);
    expand_mmov(tempx, tempy);
  }
  else if(opcode == OP_SWCF)
  {
    parse_swcf();
  }
  else if(opcode == OP_SWCC)
  {
    parse_swcc();
  }
  else if(opcode == OP_SWCR)
  {
    parse_swcr();
  }
  else if(opcode == OP_STR || opcode == OP_STRLN)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    char* str_buf = make_str((uint16_t)this_value);
    if(kb_print(str_buf, defaultchardelay, charjitter))
    {
      exe->result = EXE_ABORTED;
      return;
    }
    if(opcode == OP_STRLN)
    {
    	press_key(0x28, 0x03); // ENTER key
    	delay_ms(defaultdelay);
    	release_key(0x28, 0x03);
      delay_ms(defaultdelay);
    }
  }
  else if(opcode == OP_OLED_CUSR)
  {
    uint32_t xxx, yyy;
    stack_pop(&data_stack, &xxx);
    stack_pop(&data_stack, &yyy);
    if(xxx < SSD1306_WIDTH && yyy < SSD1306_HEIGHT)
      ssd1306_SetCursor(xxx, yyy);
  }
  else if(opcode == OP_OLED_PRNT)
  {
    uint32_t opts, addr;
    stack_pop(&data_stack, &opts);
    stack_pop(&data_stack, &addr);
    char* str_buf = make_str((uint16_t)addr);
    if(opts & 0x1)
      oled_centre_print_preserve_cursor(str_buf);
    else
      ssd1306_WriteString(str_buf, Font_7x10, White);
  }
  else if(opcode == OP_OLED_UPDE)
  {
    ssd1306_UpdateScreen();
    DS_SET_BITS(*epilogue_ptr, EPILOGUE_NEED_OLED_RESTORE);
  }
  else if(opcode == OP_OLED_CLR)
  {
    ssd1306_Fill(Black);
  }
  else if(opcode == OP_OLED_REST)
  {
    draw_profile(&all_profile_info[current_profile_number]);
    // user already restored OLED content, no need to do it again.
    DS_CLEAR_BITS(*epilogue_ptr, EPILOGUE_NEED_OLED_RESTORE);
  }
  else if(opcode == OP_OLED_LINE)
  {
    uint32_t x1,y1,x2,y2;
    stack_pop(&data_stack, &x1);
    stack_pop(&data_stack, &y1);
    stack_pop(&data_stack, &x2);
    stack_pop(&data_stack, &y2);
    clamp_uint(&x1, SSD1306_WIDTH);
    clamp_uint(&x2, SSD1306_WIDTH);
    clamp_uint(&y1, SSD1306_HEIGHT);
    clamp_uint(&y2, SSD1306_HEIGHT);
    ssd1306_Line(x1, y1, x2, y2, White);
  }
  else if(opcode == OP_OLED_RECT)
  {
    uint32_t x1,y1,x2,y2,options;
    stack_pop(&data_stack, &x1);
    stack_pop(&data_stack, &y1);
    stack_pop(&data_stack, &x2);
    stack_pop(&data_stack, &y2);
    stack_pop(&data_stack, &options);
    clamp_uint(&x1, SSD1306_WIDTH);
    clamp_uint(&x2, SSD1306_WIDTH);
    clamp_uint(&y1, SSD1306_HEIGHT);
    clamp_uint(&y2, SSD1306_HEIGHT);
    SSD1306_COLOR draw_color = White;
    if(options & 0x2)
      draw_color = Black;
    if(options & 0x1)
      ssd1306_FillRectangle(x1,y1,x2,y2,draw_color);
    else
      ssd1306_DrawRectangle(x1,y1,x2,y2,draw_color);
  }
  else if(opcode == OP_OLED_CIRC)
  {
    uint32_t x,y,radius,options;
    stack_pop(&data_stack, &x);
    stack_pop(&data_stack, &y);
    stack_pop(&data_stack, &radius);
    stack_pop(&data_stack, &options);
    clamp_uint(&x, SSD1306_WIDTH);
    clamp_uint(&y, SSD1306_HEIGHT);
    clamp_uint(&radius, SSD1306_HEIGHT/2);
    SSD1306_COLOR draw_color = White;
    if(options & 0x2)
      draw_color = Black;
    if(options & 0x1)
      ssd1306_FillCircle(x,y,radius,draw_color);
    else
      ssd1306_DrawCircle(x,y,radius,draw_color);
  }
  else if(opcode == OP_BCLR)
  {
    clear_sw_re_queue();
  }
  else if(opcode == OP_SKIPP)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    int32_t amount = this_value;
    if(amount > 0)
      exe->result = EXE_ACTION_NEXT_PROFILE;
    else if(amount < 0)
      exe->result = EXE_ACTION_PREV_PROFILE;
  }
  else if(opcode == OP_GOTOP)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    char* str_buf = make_str((uint16_t)this_value);
    int8_t profile_idx = lookup_profile_index(str_buf);
    if(profile_idx == -1)
      longjmp(jmpbuf, EXE_PROFILE_NOT_FOUND);
    exe->result = EXE_ACTION_GOTO_PROFILE;
    exe->data = (uint8_t)profile_idx;
  }
  else if(opcode == OP_SLEEP)
  {
    exe->result = EXE_ACTION_SLEEP;
  }
  else if(opcode == OP_RANDCHR)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    uint8_t char_type = this_value & 0xff;
    char randc = get_random_char(char_type);
    memset(make_str_buf, 0, MKSTR_BUF_SIZE);
    make_str_buf[0] = randc;
    if(randc != 0 && (this_value & 0x200))
      ssd1306_WriteString(make_str_buf, Font_7x10, White);
    if(randc != 0 && (this_value & 0x100))
      kb_print(make_str_buf, defaultchardelay, charjitter);
  }
  else if(opcode == OP_PUTS)
  {
    uint32_t this_value;
    stack_pop(&data_stack, &this_value);
    uint16_t str_addr = this_value & 0xffff;
    uint16_t nchar = (this_value >> 16) & 0xfff;
    make_str((uint16_t)str_addr);
    if(nchar != 0 && nchar < READ_BUF_SIZE)
      read_buffer[nchar] = 0; 
    if(this_value & 0x20000000)
      ssd1306_WriteString(read_buffer, Font_7x10, White);
    if(this_value & 0x40000000)
      oled_centre_print_preserve_cursor(read_buffer);
    if(this_value & 0x80000000)
      kb_print(read_buffer, defaultchardelay, charjitter);
  }
  else if(opcode == OP_HIDTX)
  {
    uint32_t addr;
    stack_pop(&data_stack, &addr);
    if(addr + HIDTX_PACKET_SIZE >= SCRATCH_MEM_END_ADDRESS_INCLUSIVE)
      longjmp(jmpbuf, EXE_ILLEGAL_ADDR);
    USBD_CUSTOM_HID_SendReport(bin_buf+addr);
  }
  else
  {
    // ESP_LOGE(TAG, "Unimplemented opcode: %d\n", opcode);
    longjmp(jmpbuf, EXE_ILLEGAL_INSTRUCTION);
  }
}

void run_dsb(exe_context* ctx, uint8_t this_key_id, char* dsb_path, uint8_t is_cached, uint8_t* dsb_cache)
{
  uint32_t this_dsb_size = DSB_CACHE_BYTE_SIZE;
  current_key_id = this_key_id;
  if(is_cached)
  {
    memset(bin_buf, 0, BIN_BUF_SIZE);
    memcpy(bin_buf, dsb_cache, DSB_CACHE_BYTE_SIZE);
  }
  else
  {
    uint8_t dsb_load_result = load_dsb(dsb_path, &this_dsb_size);
    if(dsb_load_result)
    {
      ctx->result = dsb_load_result;
      return;
    }
  }
  memset(memIO_buf, 0, MEMIO_BUF_SIZE);

  uint16_t data_stack_size_bytes = STACK_BASE_ADDR - this_dsb_size - STACK_MOAT_BYTES;
  stack_init(&data_stack, bin_buf, STACK_BASE_ADDR, data_stack_size_bytes);

  defaultdelay = DEFAULT_NONCHAR_DELAY_MS;
  defaultchardelay = DEFAULT_CHAR_DELAY_MS;
  charjitter = 0;
  rand_max = 65535;
  rand_min = 0;
  loop_size = 0;
  epilogue_ptr = &ctx->epilogue_actions;
  allow_abort = 0;
  disable_autorepeat = 0;
  srand(millis());

  int panic_code = setjmp(jmpbuf);
  if(panic_code != 0)
  {
    ctx->result = panic_code;
    return;
  }
  while(1)
  {
    execute_instruction(ctx);
    ctx->this_pc = ctx->next_pc;
    if(ctx->result != EXE_OK)
      break;
    if(ctx->this_pc > this_dsb_size)
      break;
  }
  disable_autorepeat ? DS_SET_BITS(*epilogue_ptr, EPILOGUE_DONT_AUTO_REPEAT) : DS_CLEAR_BITS(*epilogue_ptr, EPILOGUE_DONT_AUTO_REPEAT);

  if(is_cached == 0 && this_dsb_size <= DSB_CACHE_BYTE_SIZE)
  {
    uint8_t is_press = strstr(dsb_path, key_release_file_string) == NULL;
    dsbc_add(current_profile_number, this_key_id, is_press, millis(), bin_buf, this_dsb_size);
    // printf("added %02d %02d %02d to cache!\n", current_profile_number, this_key_id, is_press);
  }
}
